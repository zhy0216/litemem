# LiteMemory 技术文档

## 项目概述

LiteMemory 是一个为 AI 代理设计的长期记忆管理系统，通过语义嵌入和 LLM 驱动的更新机制，提取、存储和检索对话中的事实信息。

**核心目标**：将原始对话转化为持久化、结构化的记忆，支持语义检索和智能合并更新。

## 目录结构

```
src/
├── buffer/              # 短期消息缓冲（提取前暂存）
├── embeddings/          # 向量嵌入生成与管理
├── llm/                 # LLM 交互与提示词
├── mcp/                 # Model Context Protocol 服务器
├── retriever/           # 记忆检索策略
├── storage/             # 数据库与向量存储
├── types/               # TypeScript 类型定义
├── utils/               # 日志、归一化、分词工具
├── liteMem.ts           # 主控制器
├── index.ts             # 公共 API 导出
└── example.ts           # 使用示例
```

## 核心模块

### 1. LiteMemory (liteMem.ts)

主控制器，协调所有组件。

**主要职责**：
- 消息缓冲与提取触发逻辑
- 从 LLM 提取的事实创建记忆条目
- 语义检索记忆
- 记忆合并/更新操作
- Token 使用量追踪

**关键方法**：
- `initialize()` - 初始化数据库 schema
- `addMemory()` - 缓冲消息并触发提取
- `retrieve()` - 按语义相似度查询记忆
- `constructUpdateQueueAllEntries()` - 构建更新候选队列
- `offlineUpdateAllEntries()` - 合并和归并记忆

**缓冲机制**：
- 默认 2000 token 限制
- 达到 10 条消息或显式 `forceExtract` 时触发提取
- 支持按角色过滤（user_only, assistant_only, hybrid）

### 2. Storage 模块

#### TursoClient (storage/turso.ts)
- 封装 `@libsql/client` 用于 SQLite 数据库访问
- 支持本地文件数据库和远程 Turso 服务器
- 初始化 schema，`memories` 表使用 1536 维 F32_BLOB 存储嵌入

#### VectorStore (storage/vectorStore.ts)
- 管理记忆的 CRUD 操作
- 实现内存中的余弦相似度搜索
- 关键操作：`insert()`, `search()`, `update()`, `delete()`, `getAll()`

**数据库 Schema**：
- 每条记忆 20+ 字段（id, timestamp, metadata, embeddings, updateQueue 等）
- F32_BLOB 格式高效存储嵌入向量
- updateQueue 以 JSON 格式存储关联记忆

### 3. LLM 模块

#### OpenRouterManager (llm/openrouter.ts)
- 通过 OpenRouter API 调用 LLM（兼容 OpenAI SDK）
- `metaTextExtract()` - 从消息片段提取事实（JSON 模式）
- `callUpdateLlm()` - 决定记忆更新操作（更新/删除/忽略）
- `generateResponse()` - 通用 LLM 响应生成

#### Prompts (llm/prompts.ts)
- **METADATA_GENERATE_PROMPT** - 从对话中提取所有可能的事实
- **UPDATE_PROMPT** - 决定是否合并、删除或忽略记忆条目

### 4. Embeddings 模块

#### OpenRouterEmbedder (embeddings/openrouter.ts)
- 通过 OpenRouter 生成文本嵌入
- 内存缓存减少 API 调用
- 支持批量嵌入
- 可配置维度（默认 1536，text-embedding-3-small）

### 5. Buffer 模块

#### ShortTermBuffer (buffer/shortTerm.ts)
- LLM 提取前收集消息
- Token 感知的缓冲（追踪累计 token）
- `add()` - 返回是否准备好提取
- `flush()` - 获取所有消息并清空
- `getTokenCount()` - 当前 token 使用量

### 6. Retriever 模块

#### EmbeddingRetriever (retriever/embedding.ts)
- 基于向量相似度的语义搜索
- 封装 embedder + vector store

#### ContextRetriever (retriever/context.ts)
- BM25 关键词搜索的占位实现（TODO）
- 用于混合检索策略

### 7. MCP Server (mcp/server.ts)

Model Context Protocol 实现，将 LiteMemory 暴露为可调用工具：
- `addMemory` - 添加用户/助手消息对
- `retrieveMemory` - 语义搜索
- `offlineUpdate` - 运行合并
- `getStatistics` - Token 使用统计
- `getTimestamp` - 获取当前时间

### 8. Utils 模块

- **Logger** - 结构化日志（debug, info, warn, error）
- **MessageNormalizer** - 解析会话时间戳，分配递增时间戳
- **Tokenizer** - 近似 token 计数（~4 字符/token）

## 技术栈

| 类别 | 技术 |
|------|------|
| 语言 | TypeScript |
| 数据库 | Turso/LibSQL (SQLite) |
| LLM API | OpenRouter（兼容 OpenAI SDK） |
| 嵌入模型 | text-embedding-3-small (1536维) |
| 协议 | Model Context Protocol |

## 数据流

### 1. 添加记忆流程 (addMemory)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              addMemory()                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. 消息归一化 (MessageNormalizer)                                           │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ • 解析时间戳格式 ("2023/05/20 (Sat) 00:44" 或 ISO)                   │ │
│     │ • 提取 weekday 信息                                                  │ │
│     │ • 分配递增的 sequenceNumber                                          │ │
│     │ • 输出: NormalizedMessage[]                                          │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. 消息缓冲 (messageBuffer)                                                 │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ • 将归一化消息加入缓冲区                                              │ │
│     │ • 检查触发条件:                                                       │ │
│     │   - forceExtract = true                                              │ │
│     │   - messageBuffer.length >= 10                                       │ │
│     │ • 未触发则返回，等待更多消息                                           │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. 角色过滤 (filterMessagesByRole)                                          │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ 根据 config.messagesUse 过滤:                                        │ │
│     │ • user_only    → 仅保留 role='user' 的消息                           │ │
│     │ • assistant_only → 仅保留 role='assistant' 的消息                    │ │
│     │ • hybrid       → 保留所有消息                                         │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  4. LLM 事实提取 (OpenRouterManager.metaTextExtract)                         │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ 输入格式化:                                                           │ │
│     │   "[2023/05/20, Sat] 0.user: 我喜欢喝咖啡"                           │ │
│     │   "[2023/05/20, Sat] 1.assistant: 好的，记住了"                       │ │
│     │                                                                      │ │
│     │ 调用 LLM (JSON mode):                                                │ │
│     │   System: METADATA_GENERATE_PROMPT                                   │ │
│     │   User: "--- Topic 1 ---\n{formatted_messages}"                      │ │
│     │                                                                      │ │
│     │ 输出: ExtractedFact[] = [{sourceId: 0, fact: "用户喜欢喝咖啡"}]       │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  5. 创建记忆条目 (createMemoryEntries)                                       │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ 对每个提取的事实:                                                     │ │
│     │  a) 关联源消息 (通过 sourceId 找到原始 NormalizedMessage)             │ │
│     │  b) 创建 MemoryEntry:                                                │ │
│     │     {                                                                │ │
│     │       id: uuid(),                                                    │ │
│     │       memory: "用户喜欢喝咖啡",                                       │ │
│     │       timeStamp: "2023-05-20T00:44:00Z",                            │ │
│     │       floatTimeStamp: 1684539840.0,                                  │ │
│     │       weekday: "Sat",                                                │ │
│     │       speakerId, speakerName, ...                                    │ │
│     │     }                                                                │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  6. 嵌入生成 (OpenRouterEmbedder.embed)                                      │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ • 调用 OpenRouter API: text-embedding-3-small                        │ │
│     │ • 输入: "用户喜欢喝咖啡"                                              │ │
│     │ • 输出: number[1536] (向量)                                          │ │
│     │ • 缓存: 相同文本复用已计算的嵌入                                       │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  7. 向量存储 (VectorStore.insert)                                            │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ • 将 embedding 转换为 Float32 Blob                                   │ │
│     │ • 执行 SQL INSERT INTO memories (...)                                │ │
│     │ • 存储 20+ 字段 + 1536维嵌入向量                                      │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                        ┌───────────────────────┐
                        │  清空 messageBuffer   │
                        │  返回 AddMemoryResult │
                        └───────────────────────┘

```

### 2. 检索流程 (retrieve)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           retrieve(query, limit, filters)                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  1. 查询嵌入生成                                                              │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ queryEmbedding = embedder.embed(query)                              │ │
│     │ 输入: "用户的饮食偏好"                                                │ │
│     │ 输出: number[1536]                                                   │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  2. 向量搜索 (VectorStore.search)                                            │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ a) 加载所有记忆条目 (含嵌入向量)                                       │ │
│     │ b) 应用过滤器:                                                        │ │
│     │    - floatTimeStamp: {gte, lte}  时间范围                            │ │
│     │    - speakerId                    说话者                              │ │
│     │    - category                     分类                                │ │
│     │ c) 计算余弦相似度:                                                    │ │
│     │    score = (a·b) / (|a| × |b|)                                       │ │
│     │ d) 按分数降序排序，取 top N                                           │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  3. 格式化结果                                                               │
│     ┌─────────────────────────────────────────────────────────────────────┐ │
│     │ 输出格式: "{timeStamp} {weekday} {memory}"                          │ │
│     │ 示例:                                                                │ │
│     │   "2023-05-20T00:44:00Z Sat 用户喜欢喝咖啡"                          │ │
│     │   "2023-05-21T10:30:00Z Sun 用户不吃辣"                              │ │
│     └─────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3. 离线更新流程 (offlineUpdate)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    离线更新流程 (两阶段)                                      │
└─────────────────────────────────────────────────────────────────────────────┘

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃  阶段 1: 构建更新队列 (constructUpdateQueueAllEntries)                        ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  对每条记忆:                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ 1. 搜索相似的早期记忆 (floatTimeStamp <= 当前记忆)                       │ │
│  │ 2. 排除自身，取 topK 个候选                                              │ │
│  │ 3. 存储候选队列: updateQueue = [{id, score}, ...]                       │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
│  示例:                                                                       │
│  记忆 A: "用户喜欢喝咖啡" (2023-05-20)                                       │
│  记忆 B: "用户每天早上喝咖啡" (2023-05-25)                                   │
│    → B.updateQueue = [{id: A, score: 0.92}]                                 │
└─────────────────────────────────────────────────────────────────────────────┘

┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃  阶段 2: 执行更新 (offlineUpdateAllEntries)                                   ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  对每条有高相似度候选的记忆 (score >= threshold):                             │
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │ 1. 调用 LLM 决策 (callUpdateLlm):                                       │ │
│  │    System: UPDATE_PROMPT                                                │ │
│  │    User: "Target: 用户喜欢喝咖啡                                         │ │
│  │           Candidates: - 用户每天早上喝咖啡"                              │ │
│  │                                                                         │ │
│  │ 2. LLM 返回决策:                                                        │ │
│  │    • action: "update" → 合并信息，更新 memory 字段                       │ │
│  │    • action: "delete" → 删除重复/过时记忆                                │ │
│  │    • action: "ignore" → 保持不变                                         │ │
│  │                                                                         │ │
│  │ 3. 执行决策:                                                             │ │
│  │    - update: vectorStore.update(id, {memory: newMemory})                │ │
│  │    - delete: vectorStore.delete(id)                                     │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                        ┌───────────────────────┐
                        │  记忆库完成去重/合并  │
                        └───────────────────────┘
```

### 数据流总结

| 流程 | 输入 | 处理 | 输出 |
|------|------|------|------|
| addMemory | Message[] | 归一化→缓冲→LLM提取→嵌入→存储 | MemoryEntry[] |
| retrieve | query string | 嵌入→余弦相似度→过滤→排序 | 格式化文本 |
| offlineUpdate | 全量记忆 | 相似度队列→LLM决策→更新/删除 | 合并后的记忆库 |

## 组件依赖图

```
LiteMemory (主控制器)
  ├── TursoClient → VectorStore
  ├── OpenRouterManager → LLM prompts
  ├── OpenRouterEmbedder → 嵌入缓存
  ├── MessageNormalizer → Tokenizer
  └── EmbeddingRetriever (可选)
```

## 配置系统

```json
{
  "messagesUse": "user_only",        // 按角色过滤消息
  "metadataGenerate": true,          // 启用 LLM 提取
  "retrieveStrategy": "embedding",   // 检索方法
  "update": "offline",               // 更新时机策略
  "llm": { ... },                    // OpenRouter LLM 配置
  "embedder": { ... },               // 嵌入器配置
  "turso": { ... },                  // 数据库配置
  "logging": { "level": "info" }     // 日志级别
}
```

## 核心类型

```typescript
// 记忆条目
interface MemoryEntry {
  id: string;
  timestamp: number;
  category: string;
  memory: string;
  embedding: number[];
  updateQueue: UpdateCandidate[];
  // ... 20+ 字段
}

// 消息
interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp?: string;
}

// 提取的事实
interface ExtractedFact {
  sourceId: string;
  fact: string;
}
```

## 已知限制与 TODO

- **主题分割**：当前使用简单的 10 条消息阈值，需实现更智能的批处理
- **BM25 搜索**：ContextRetriever 为占位实现
- **向量索引**：使用内存中余弦相似度，无原生向量索引
- **Token 计数**：为近似值，应集成 tiktoken
- **性能**：内存相似度搜索 O(n)，无分区或层级索引

## 公共 API

```typescript
export { LiteMemory }                  // 主类
export { TursoClient, VectorStore }   // 存储
export { OpenRouterManager }          // LLM 管理器
export { OpenRouterEmbedder }         // 嵌入器
export { Logger }                     // 日志
export { MessageNormalizer }          // 归一化
export * from './types'               // 所有类型定义
```
